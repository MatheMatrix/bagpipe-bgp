# vim: tabstop=4 shiftwidth=4 softtabstop=4
# encoding: utf-8

# Copyright 2014 Orange
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""

.. module:: test_route_table_manager
   :synopsis: module that defines several test cases for the route_table_manager module.
   In particular, unit tests for RouteTableManager class.
   Setup : Start RouteTableManager thread instance.
   TearDown : Stop RouteTableManager thread instance.
   RouteTableManager is in charge to maintain the list of Workers (TrackerWorker, ExaBGPPeerWorker,
   BGPPeerWorker) subscriptions, to process BGB route events and to dispatch BGP routes to the Workers according
   to their subscriptions.
   Mock class is used to stub Workers.
   Tests are organized as follow :
   - testAx use cases to test worker subscriptions to route target (or match)
     1- with no route to synthetise
     2- with routes to synthetise <=> advertise existing routes to the new worker subscription according following rules :
        - route should not be synthetised to its source,
        - route should not be synthetised between BGPPeerWorkers
        - route should not be synthetised if already send to worker for another RT
     For both use cases check that (worker, match) is correctly recorded by RouteTableManager
     Other test cases : re-subscription to check routes are not synthetised
   - testBx use cases to test worker unsubscriptions to match (without and with routes to synthetise) :
     same rules should be applied to generate withdraw events.
     Check (worker, match) has been deleted
     Other test cases : unsubscription to match or by worker not registered
   - testCx to test the processing of route event generated by a worker.
     2 types of route event : advertise (new or update) or withdraw a route entry
     1- advertise or withdraw a route entry without event propagation to workers : check that entry is
     recorded/deleted
     2- advertise (new or update) or withdraw with event propagation : to test dispatching of route events
     to the workers according to their subscriptions.
     Other test cases : withdraw of a not registered route, advertise of the same route (same attr and RTs)
   - testDx : to test worker cleanup
   - testEx : to test dumpState

"""

import mock
import time

from testtools import TestCase

from bagpipe.bgp.tests import BaseTestBagPipeBGP, RT1, RT2, RT3, NLRI1, NLRI2, NH1, NH2

from bagpipe.bgp.engine import RouteEvent, Subscription, Unsubscription
from bagpipe.bgp.engine.worker import Worker
from bagpipe.bgp.engine.bgp_peer_worker import BGPPeerWorker
from bagpipe.bgp.engine.route_table_manager import RouteTableManager, Match, WorkerCleanupEvent

from exabgp.structure.address import AFI, SAFI

MATCH1 = Match(AFI(AFI.ipv4), SAFI(SAFI.mpls_vpn), RT1)
MATCH2 = Match(AFI(AFI.ipv4), SAFI(SAFI.mpls_vpn), RT2)
MATCH3 = Match(AFI(AFI.ipv4), SAFI(SAFI.mpls_vpn), RT3)


class TestRouteTableManager(TestCase, BaseTestBagPipeBGP):

    def setUp(self):
        super(TestRouteTableManager, self).setUp()
        self.routeTableManager = RouteTableManager()
        self.routeTableManager.start()

    def tearDown(self):
        super(TestRouteTableManager, self).tearDown()
        self.routeTableManager.stop()
        self.routeTableManager.join()

    def _newMockWorker(self, workerName, workerType):
        mockWorker = mock.Mock(spec=workerType)
        mockWorker.name = workerName
        mockWorker.enqueue = mock.Mock()
        return mockWorker

    def _workerSubscriptions(self, worker, rts, afi=AFI(AFI.ipv4), safi=SAFI(SAFI.mpls_vpn)):
        for rt in rts:
            subscribe = Subscription(afi, safi, rt, worker)
            self.routeTableManager.enqueue(subscribe)

    def _workerUnsubscriptions(self, worker, rts, afi=AFI(AFI.ipv4), safi=SAFI(SAFI.mpls_vpn)):
        for rt in rts:
            unsubscribe = Unsubscription(afi, safi, rt, worker)
            self.routeTableManager.enqueue(unsubscribe)

    def _checkSubscriptions(self, worker, matches):
        for match in matches:
            self.assertTrue(match in self.routeTableManager.getWorkerSubscriptions(worker), "Subscription not found")

    def _checkUnsubscriptions(self, worker, matches):
        for match in matches:
            self.assertTrue(match not in self.routeTableManager.getWorkerSubscriptions(worker), "Subscription found")

    def _checkRouteEntry(self, worker, entry):
        self.assertTrue(entry in self.routeTableManager.getWorkerRouteEntries(worker), "Route entry not found")

    def _checkNoRouteEntry(self, worker, entry):
        self.assertTrue(entry not in self.routeTableManager.getWorkerRouteEntries(worker), "Route entry found")

    def _checkRouteEventsEnqueue(self, eventsEnqueue, entriesAdvertised, nlriWithdrawn):
        for (callArgs, _) in eventsEnqueue:
            if (callArgs[0].type == RouteEvent.ADVERTISE):
                self.assertTrue(callArgs[0].routeEntry in entriesAdvertised, "Bad advertised route")
                entriesAdvertised.remove(callArgs[0].routeEntry)
            else:
                self.assertTrue(callArgs[0].routeEntry.nlri in nlriWithdrawn, "Bad withdrawn route")
                nlriWithdrawn.remove(callArgs[0].routeEntry.nlri)
        self.assertTrue(entriesAdvertised == [], "Entries not advertised")
        self.assertTrue(nlriWithdrawn == [], "Entries not withdrawn")

    def testA1_SubscriptionsWithNoRouteToSynthetise(self):
        # Worker1 subscribes to RT1 and RT2
        mockWorker1 = self._newMockWorker("Worker-1", Worker)
        self._workerSubscriptions(mockWorker1, [ RT1, RT2 ])
        # Waiting for RouteTableManager thread finishes to process the subscriptions
        self._wait()
        # check subscriptions
        self._checkSubscriptions(mockWorker1, [ MATCH1, MATCH2 ])

    def testA2_SubscriptionsWithRouteToSynthetise(self):
        # BGPPeerWorker1 advertises a route for RT1 and RT2
        mockBGPPeerWorker1 = self._newMockWorker("BgpPeerWorker-1", BGPPeerWorker)
        routeEvent1 = self._newRouteEvent(self.routeTableManager, RouteEvent.ADVERTISE, NLRI1, [ RT1 , RT2 ],
                                          mockBGPPeerWorker1, NH1)
        # BGPPeerWorker1 advertises an other route for RT2
        routeEvent2 = self._newRouteEvent(self.routeTableManager, RouteEvent.ADVERTISE, NLRI2, [ RT2 ],
                                          mockBGPPeerWorker1, NH1)
        # BGPPeerWorker1 subscribes to RT1
        self._workerSubscriptions(mockBGPPeerWorker1, [ RT1 ])
        # Worker1 subscribes to RT1 and RT2
        mockWorker1 = self._newMockWorker("Worker-1", Worker)
        self._workerSubscriptions(mockWorker1, [ RT1, RT2 ])
        # Worker2 subscribes to RT1
        mockWorker2 = self._newMockWorker("Worker-2", Worker)
        self._workerSubscriptions(mockWorker2, [ RT1 ])
        # Worker3 subscribes to RT3
        mockWorker3 = self._newMockWorker("Worker-3", Worker)
        self._workerSubscriptions(mockWorker3, [ RT3 ])
        # BGPPeerWorker2 subscribes to RT1
        mockBGPPeerWorker2 = self._newMockWorker("BGPPeerWorker-2", BGPPeerWorker)
        self._workerSubscriptions(mockBGPPeerWorker2, [ RT1 ])
        # Waiting for RouteTableManager thread finishes to process the subscription
        self._wait()
        # check route entry synthetised
        self.assertEqual(0, mockBGPPeerWorker1.enqueue.call_count, "Route should not be synthetised to its source")
        self.assertEqual(0, mockWorker3.enqueue.call_count, "no route should be synthetised to Worker3")
        self.assertEqual(0, mockBGPPeerWorker2.enqueue.call_count, "Route should not be synthetised between BGPPeerWorkers")
        self.assertEqual(2, mockWorker1.enqueue.call_count, "2 routes advertised should be synthetised to Worker1")
        self._checkRouteEventsEnqueue(mockWorker1.enqueue.call_args_list,
                                      [routeEvent1.routeEntry, routeEvent2.routeEntry ], [])
        self.assertEqual(1, mockWorker2.enqueue.call_count, "1 route advertise should be synthetised to Worker2")
        self._checkRouteEventsEnqueue(mockWorker2.enqueue.call_args_list, [ routeEvent1.routeEntry ], [])

    def testA3_ReSubscription(self):
        # BGPPeerWorker1 advertises a route for RT1 and RT2
        mockBGPPeerWorker1 = self._newMockWorker("BgpPeerWorker-1", BGPPeerWorker)
        routeEvent = self._newRouteEvent(self.routeTableManager, RouteEvent.ADVERTISE, NLRI1, [ RT1, RT2 ],
                                         mockBGPPeerWorker1, NH1)
        # Worker1 subscribes to RT1 and RT2
        mockWorker1 = self._newMockWorker("Worker-1", Worker)
        self._workerSubscriptions(mockWorker1, [ RT1, RT2 ])
        # Worker1 subscribes again to RT1
        self._workerSubscriptions(mockWorker1, [ RT1 ])
        # Worker2 subscribes to RT1
        mockWorker2 = self._newMockWorker("Worker-2", Worker)
        self._workerSubscriptions(mockWorker2, [ RT1 ])
        # Worker1 subscribes again to RT2
        self._workerSubscriptions(mockWorker2, [ RT2 ])
        # Waiting for RouteTableManager thread finishes to process the subscription
        self._wait()
        # check route entry synthetised
        self.assertEqual(1, mockWorker1.enqueue.call_count, "1 route advertised should be synthetised to Worker1")
        self._checkRouteEventsEnqueue(mockWorker1.enqueue.call_args_list,
                                      [routeEvent.routeEntry ], [])
        self.assertEqual(1, mockWorker2.enqueue.call_count, "1 route advertised should be synthetised to Worker2")
        self._checkRouteEventsEnqueue(mockWorker2.enqueue.call_args_list,
                                      [routeEvent.routeEntry ], [])

    def testB1_UnsubscriptionWithNoRouteToSynthetise(self):
        # Worker1 subscribes to RT1 and RT2
        mockWorker1 = self._newMockWorker("Worker-1", Worker)
        self._workerSubscriptions(mockWorker1, [ RT1, RT2 ])
        # BGPPeerWorker1 subscribes to RT1 and RT2
        mockBGPPeerWorker1 = self._newMockWorker("BGPPeerWorker-1", BGPPeerWorker)
        self._workerSubscriptions(mockBGPPeerWorker1, [ RT1, RT2 ])
        # Worker1 unsubscribes to RT1
        self._workerUnsubscriptions(mockWorker1, [ RT1 ])
        # BGPPeerWorker1 unsubscribes to RT1 and RT2
        self._workerUnsubscriptions(mockBGPPeerWorker1, [ RT1, RT2 ])
        # Waiting for RouteTableManager thread finishes to process the subscription
        self._wait()
        # check subscription/unsubscriptions
        self._checkUnsubscriptions(mockWorker1, [ MATCH1 ])
        self._checkSubscriptions(mockWorker1, [ MATCH2 ])
        self._checkUnsubscriptions(mockBGPPeerWorker1, [ MATCH1, MATCH2 ])

    def testB2_UnsubscriptionWithRouteToSynthetise(self):
        # BGPPeerWorker1 advertises a route for RT1
        mockBGPPeerWorker1 = self._newMockWorker("BGPPeerWorker-1", BGPPeerWorker)
        routeEvent1 = self._newRouteEvent(self.routeTableManager, RouteEvent.ADVERTISE, NLRI1, [ RT1, RT2 ],
                                          mockBGPPeerWorker1, NH1)
        # BGPPeerWorker1 advertises an other route for RT2
        routeEvent2 = self._newRouteEvent(self.routeTableManager, RouteEvent.ADVERTISE, NLRI2, [ RT2 ],
                                          mockBGPPeerWorker1, NH1)
        # BGPPeerWorker1 subscribes to RT1
        self._workerSubscriptions(mockBGPPeerWorker1, [ RT1 ])
        # Worker1 subscribes to RT1 and RT2
        mockWorker1 = self._newMockWorker("Worker-1", Worker)
        self._workerSubscriptions(mockWorker1, [ RT1, RT2 ])
        # Worker2 subscribes to RT2
        mockWorker2 = self._newMockWorker("Worker-2", Worker)
        self._workerSubscriptions(mockWorker2, [ RT2 ])
        # Worker3 subscribes to RT3
        mockWorker3 = self._newMockWorker("Worker-3", Worker)
        self._workerSubscriptions(mockWorker3, [ RT3 ])
        # BGPPeerWorker2 subscribes to RT1
        mockBGPPeerWorker2 = self._newMockWorker("BGPPeerWorker-2", BGPPeerWorker)
        self._workerSubscriptions(mockBGPPeerWorker2, [ RT1 ])
        # Workers and BGPPeerWorker unsubscriptions
        self._workerUnsubscriptions(mockBGPPeerWorker1, [ RT1 ])
        self._workerUnsubscriptions(mockWorker1, [ RT1 ])
        self._workerUnsubscriptions(mockWorker2, [ RT2 ])
        self._workerUnsubscriptions(mockWorker3, [ RT3 ])
        self._workerUnsubscriptions(mockBGPPeerWorker2, [ RT1 ])
        # Waiting for RouteTableManager thread finishes to process the subscription
        self._wait()
        # check route entry synthetised
        self.assertEqual(0, mockBGPPeerWorker1.enqueue.call_count, "Route should not be synthetised to its source")
        self.assertEqual(0, mockWorker3.enqueue.call_count, "no route should be synthetised to Worker3")
        self.assertEqual(0, mockBGPPeerWorker2.enqueue.call_count, "Route should not be synthetised between BGPPeerWorkers")
        self.assertEqual(2, mockWorker1.enqueue.call_count, "2 routes should be synthetised to Worker1 : 2 advertise")
        self._checkRouteEventsEnqueue(mockWorker1.enqueue.call_args_list,
                                      [routeEvent1.routeEntry, routeEvent2.routeEntry ], [])
        self.assertEqual(4, mockWorker2.enqueue.call_count, "4 routes should be synthetised to Worker2 : 2 advertise and 2 withdraw")
        self._checkRouteEventsEnqueue(mockWorker2.enqueue.call_args_list,
                                      [routeEvent1.routeEntry, routeEvent2.routeEntry ],
                                      [routeEvent1.routeEntry.nlri, routeEvent2.routeEntry.nlri])

    def testB3_UnsubscriptionNotRegistered(self):
        # Worker1 subscribes to RT1
        mockWorker1 = self._newMockWorker("Worker-1", Worker)
        self._workerSubscriptions(mockWorker1, [ RT1 ])
        # Worker1 unsubscribes to RT2
        self._workerUnsubscriptions(mockWorker1, [ RT2 ])
        # BGPPeerWorker1 unsubscribes to RT1
        mockBGPPeerWorker1 = self._newMockWorker("BGPPeerWorker-1", BGPPeerWorker)
        self._workerUnsubscriptions(mockBGPPeerWorker1, [ RT1, RT2 ])
        # Waiting for RouteTableManager thread finishes to process the subscription
        self._wait()
        # check subscription/unsubscriptions
        self._checkSubscriptions(mockWorker1, [ MATCH1 ])
        self._checkUnsubscriptions(mockBGPPeerWorker1, [ MATCH1, MATCH2 ])

    def testC1_routeAdvertiseByWorkerWithoutPropagation(self):
        # Worker1 advertises a route for RT1 and RT2
        mockWorker1 = self._newMockWorker("Worker-1", Worker)
        routeEvent = self._newRouteEvent(self.routeTableManager, RouteEvent.ADVERTISE, NLRI1, [ RT1, RT2 ],
                                         mockWorker1, NH1)
        # Waiting for RouteTableManager thread finishes to process routeEvent
        self._wait()
        # check route entry has been inserted
        self._checkRouteEntry(mockWorker1, routeEvent.routeEntry)

    def testC2_routeWithdrawByWorkerWithoutPropagation(self):
        # Worker1 advertises then withdraws a route
        mockWorker1 = self._newMockWorker("Worker-1", Worker)
        _ = self._newRouteEvent(self.routeTableManager, RouteEvent.ADVERTISE, NLRI1, [ RT1, RT2 ], mockWorker1, NH1)
        routeEvent = self._newRouteEvent(self.routeTableManager, RouteEvent.WITHDRAW, NLRI1, [ RT1 ], mockWorker1, NH1)
        # Waiting for RouteTableManager thread finishes to process routeEvent
        self._wait()
        # check route entry has been removed
        self._checkNoRouteEntry(mockWorker1, routeEvent.routeEntry)

    def testC3_routeAdvertiseByBGPPeerWithPropagation(self):
        # Worker1 subscribes to RT1
        mockWorker1 = self._newMockWorker("Worker-1", Worker)
        self._workerSubscriptions(mockWorker1, [ RT1 ])
        # Worker2 subscribes to RT2
        mockWorker2 = self._newMockWorker("Worker-2", Worker)
        self._workerSubscriptions(mockWorker2, [ RT2 ])
        # BGPPeerWorker1 subscribes to RT1 and RT2
        mockBGPPeerWorker1 = self._newMockWorker("BGPPeerWorker-1", BGPPeerWorker)
        self._workerSubscriptions(mockBGPPeerWorker1, [ RT1, RT2 ])
        # BGPPeerWorker2 subscribes to RT1 and RT2
        mockBGPPeerWorker2 = self._newMockWorker("BGPPeerWorker-2", BGPPeerWorker)
        self._workerSubscriptions(mockBGPPeerWorker2, [ RT1, RT2 ])
        # BGPPeerWorker1 advertises a route for RT1
        routeEvent = self._newRouteEvent(self.routeTableManager, RouteEvent.ADVERTISE, NLRI1, [ RT1 ],
                                         mockBGPPeerWorker1, NH1)
        # Waiting for RouteTableManager thread finishes to process routeEvent
        self._wait()
        # check routeEvent propagation
        self.assertEqual(1, mockWorker1.enqueue.call_count, "1 route should be propagated to Worker1")
        self._checkRouteEventsEnqueue(mockWorker1.enqueue.call_args_list, [ routeEvent.routeEntry ], [])
        self.assertEqual(0, mockWorker2.enqueue.call_count, "no route should be propagated to Worker2")
        self.assertEqual(0, mockBGPPeerWorker1.enqueue.call_count, "Route should not be propagated to its source")
        self.assertEqual(0, mockBGPPeerWorker2.enqueue.call_count, "Route should not be propagated between BGPPeerWorkers")

    def testC4_routeWithdrawByPeerWorkerWithPropagation(self):
        # Worker1 subscribes to RT1
        mockWorker1 = self._newMockWorker("Worker-1", Worker)
        self._workerSubscriptions(mockWorker1, [ RT1 ])
        # Worker2 subscribes to RT2
        mockWorker2 = self._newMockWorker("Worker-2", Worker)
        self._workerSubscriptions(mockWorker2, [ RT2 ])
        # Worker3 subscribes to RT3
        mockWorker3 = self._newMockWorker("Worker-3", Worker)
        self._workerSubscriptions(mockWorker3, [ RT3 ])
        # BGPPeerWorker1 subscribes to RT1
        mockBGPPeerWorker1 = self._newMockWorker("BGPPeerWorker-1", BGPPeerWorker)
        self._workerSubscriptions(mockBGPPeerWorker1, [ RT1 ])
        # BGPPeerWorker2 subscribes to RT2
        mockBGPPeerWorker2 = self._newMockWorker("BGPPeerWorker-2", BGPPeerWorker)
        self._workerSubscriptions(mockBGPPeerWorker2, [ RT2 ])
        # BGPPeerWorker1 advertises a route for RT1 and RT2
        routeEventA = self._newRouteEvent(self.routeTableManager, RouteEvent.ADVERTISE, NLRI1, [ RT1, RT2 ],
                                          mockBGPPeerWorker1, NH1)
        # BGPPeerWorker1 withdraw previous route (without RT
        routeEventW = self._newRouteEvent(self.routeTableManager, RouteEvent.WITHDRAW, NLRI1, [ ],
                                          mockBGPPeerWorker1, NH1)
        # Waiting for RouteTableManager thread finishes to process routeEvent
        self._wait()
        # check routeEvent propagation
        self.assertEqual(2, mockWorker1.enqueue.call_count, "2 routes should be propagated to Worker1")
        self._checkRouteEventsEnqueue(mockWorker1.enqueue.call_args_list, [ routeEventA.routeEntry ],
                                      [ routeEventW.routeEntry.nlri ])
        self.assertEqual(2, mockWorker2.enqueue.call_count, "2 routes should be propagated to Worker2")
        self._checkRouteEventsEnqueue(mockWorker2.enqueue.call_args_list, [ routeEventA.routeEntry ],
                                      [ routeEventW.routeEntry.nlri ])
        self.assertEqual(0, mockWorker3.enqueue.call_count, "No route should be propagated to Worker3")
        self.assertEqual(0, mockBGPPeerWorker1.enqueue.call_count, "Route should not be propagated to its source")
        self.assertEqual(0, mockBGPPeerWorker2.enqueue.call_count, "Route should not be propagated between BGPPeerWorkers")

    def testC5_routeUpdateByBGPPeerWithWithdrawPropagation(self):
        # Worker1 subscribes to RT1
        mockWorker1 = self._newMockWorker("Worker-1", Worker)
        self._workerSubscriptions(mockWorker1, [ RT1 ])
        # Worker2 subscribes to RT2
        mockWorker2 = self._newMockWorker("Worker-2", Worker)
        self._workerSubscriptions(mockWorker2, [ RT2 ])
        # Worker3 subscribes to RT3
        mockWorker3 = self._newMockWorker("Worker-3", Worker)
        self._workerSubscriptions(mockWorker3, [ RT3 ])
        # BGPPeerWorker1 advertises a route for RT1, RT2 and RT3
        mockBGPPeerWorker1 = self._newMockWorker("BGPPeerWorker-1", BGPPeerWorker)
        routeEvent1 = self._newRouteEvent(self.routeTableManager, RouteEvent.ADVERTISE, NLRI1, [ RT1, RT2, RT3 ],
                                          mockBGPPeerWorker1, NH1)
        # BGPPeerWorker1 advertises the same nlri with attributes NH and RTs modification
        routeEvent2 = self._newRouteEvent(self.routeTableManager, RouteEvent.ADVERTISE, NLRI1, [ RT1, RT2 ],
                                          mockBGPPeerWorker1, NH2)
        # Waiting for RouteTableManager thread finishes to process routeEvent
        self._wait()
        # check route event propagation
        # TO DO : check routeEvent.replacedRoute
        self.assertEqual(0, mockBGPPeerWorker1.enqueue.call_count, "Route should not be propagated to its source")
        self.assertEqual(2, mockWorker1.enqueue.call_count, "2 routes should be advertised to Worker1")
        self._checkRouteEventsEnqueue(mockWorker1.enqueue.call_args_list,
                                      [routeEvent1.routeEntry, routeEvent2.routeEntry ], [])
        self.assertEqual(2, mockWorker2.enqueue.call_count, "2 routes should be advertised to Worker2")
        self._checkRouteEventsEnqueue(mockWorker2.enqueue.call_args_list,
                                      [routeEvent1.routeEntry, routeEvent2.routeEntry ], [])
        self.assertEqual(2, mockWorker3.enqueue.call_count, "2 routes should be advert/withdraw to Worker3")
        self._checkRouteEventsEnqueue(mockWorker3.enqueue.call_args_list,
                                      [routeEvent1.routeEntry ], [routeEvent1.routeEntry.nlri])

    def testC6_routeReadvertised(self):
        # Worker1 subscribes to RT1
        mockWorker1 = self._newMockWorker("Worker-1", Worker)
        self._workerSubscriptions(mockWorker1, [ RT1, RT2, RT3])
        # BGPPeerWorker1 advertises a route for RT1, RT2 and RT3
        mockBGPPeerWorker1 = self._newMockWorker("BGPPeerWorker-1", BGPPeerWorker)
        routeEvent1 = self._newRouteEvent(self.routeTableManager, RouteEvent.ADVERTISE, NLRI1, [ RT1, RT2 ],
                                          mockBGPPeerWorker1, NH1)
        # BGPPeerWorker1 advertises the same nlri with same attributes and RTs
        self._newRouteEvent(self.routeTableManager, RouteEvent.ADVERTISE, NLRI1, [ RT1, RT2 ], mockBGPPeerWorker1, NH1)
        # Waiting for RouteTableManager thread finishes to process routeEvent
        self._wait()
        # check route event propagation
        self.assertEqual(0, mockBGPPeerWorker1.enqueue.call_count, "Route should not be propagated to its source")
        self.assertEqual(1, mockWorker1.enqueue.call_count, "TO BE ENHANCED : only 1 route should be advertised to Worker1")
        self._checkRouteEventsEnqueue(mockWorker1.enqueue.call_args_list, [routeEvent1.routeEntry ], [])

    def testC7_routeWithdrawNotRegistered(self):
        # Worker1 subscribes to RT1
        mockWorker1 = self._newMockWorker("Worker-1", Worker)
        self._workerSubscriptions(mockWorker1, [ RT1, RT2 ])
        # BGPPeerWorker1 advertises a route for RT1 and RT2
        mockBGPPeerWorker1 = self._newMockWorker("BGPPeerWorker-1", BGPPeerWorker)
        routeEventA = self._newRouteEvent(self.routeTableManager, RouteEvent.ADVERTISE, NLRI1, [ RT1, RT2 ],
                                          mockBGPPeerWorker1, NH1)
        # BGPPeerWorker1 withdraw a not registered route (without RT
        self._newRouteEvent(self.routeTableManager, RouteEvent.WITHDRAW, NLRI2, [ ], mockBGPPeerWorker1, NH1)
        # Waiting for RouteTableManager thread finishes to process routeEvent
        self._wait()
        # check routeEvent propagation
        self.assertEqual(1, mockWorker1.enqueue.call_count, "1 route1 should be propagated to Worker1")
        self._checkRouteEventsEnqueue(mockWorker1.enqueue.call_args_list, [ routeEventA.routeEntry ], [ ])
        self.assertEqual(0, mockBGPPeerWorker1.enqueue.call_count, "Route should not be propagated to its source")

    def testD1_WorkerCleanup(self):
        # Worker1 subscribes to RT1
        mockWorker1 = self._newMockWorker("Worker-1", Worker)
        self._workerSubscriptions(mockWorker1, [ RT1 ])
        # Worker2 subscribes to RT2
        mockWorker2 = self._newMockWorker("Worker-2", Worker)
        self._workerSubscriptions(mockWorker2, [ RT2 ])
        # BGPPeerWorker1 subscribes to RT1 and RT2
        mockBGPPeerWorker1 = self._newMockWorker("BGPPeerWorker-1", BGPPeerWorker)
        self._workerSubscriptions(mockBGPPeerWorker1, [ RT1, RT2 ])
        # BGPPeerWorker1 advertises a route for RT1 and RT2
        routeEvent1 = self._newRouteEvent(self.routeTableManager, RouteEvent.ADVERTISE, NLRI1, [ RT1 , RT2 ],
                                          mockBGPPeerWorker1, NH1)
        # BGPPeerWorker1 advertises an other route for RT2
        routeEvent2 = self._newRouteEvent(self.routeTableManager, RouteEvent.ADVERTISE, NLRI2, [ RT2 ],
                                          mockBGPPeerWorker1, NH1)
        # Cleanup Worker1
        self.routeTableManager.enqueue(WorkerCleanupEvent(mockBGPPeerWorker1))
        # Waiting for RouteTableManager thread finishes to process the subscriptions
        self._wait()
        # check unsubscriptions
        self._checkUnsubscriptions(mockBGPPeerWorker1, [ MATCH1, MATCH2 ])
        # Check route synthetise to Worker1 and Worker2
        self.assertEqual(2, mockWorker1.enqueue.call_count, "2 routes should be advert/withdraw to Worker1")
        self._checkRouteEventsEnqueue(mockWorker1.enqueue.call_args_list,
                                      [routeEvent1.routeEntry ], [routeEvent1.routeEntry.nlri])
        self.assertEqual(4, mockWorker2.enqueue.call_count, "4 routes should be advert/withdraw to Worker2")
        self._checkRouteEventsEnqueue(mockWorker2.enqueue.call_args_list,
                                      [routeEvent1.routeEntry, routeEvent2.routeEntry ],
                                      [routeEvent1.routeEntry.nlri, routeEvent2.routeEntry.nlri])
        # Check route entries have been removed for BGPPeerWorker1
        self._checkNoRouteEntry(mockBGPPeerWorker1, routeEvent1.routeEntry)
        self._checkNoRouteEntry(mockBGPPeerWorker1, routeEvent2.routeEntry)

    def testE1_DumpState(self):
        # BGPPeerWorker1 advertises a route for RT1 and RT2
        mockBGPPeerWorker1 = self._newMockWorker("BgpPeerWorker-1", BGPPeerWorker)
        self._newRouteEvent(self.routeTableManager, RouteEvent.ADVERTISE, NLRI1, [ RT1 , RT2 ], mockBGPPeerWorker1, NH1)
        # BGPPeerWorker1 advertises an other route for RT2
        self._newRouteEvent(self.routeTableManager, RouteEvent.ADVERTISE, NLRI2, [ RT2 ], mockBGPPeerWorker1, NH1)
        # BGPPeerWorker1 subscribes to RT1
        self._workerSubscriptions(mockBGPPeerWorker1, [ RT1 ])
        # Worker1 subscribes to RT1 and RT2
        mockWorker1 = self._newMockWorker("Worker-1", Worker)
        self._workerSubscriptions(mockWorker1, [ RT1, RT2 ])
        # Worker2 subscribes to RT1
        mockWorker2 = self._newMockWorker("Worker-2", Worker)
        self._workerSubscriptions(mockWorker2, [ RT1 ])
        # Worker3 subscribes to RT3
        mockWorker3 = self._newMockWorker("Worker-3", Worker)
        self._workerSubscriptions(mockWorker3, [ RT3 ])

        # Waiting for RouteTableManager thread finishes to process the subscriptions and route event processing
        self._wait()

        self.routeTableManager._dumpState()
